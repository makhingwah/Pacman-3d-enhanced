<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Pac‑Man 3D Enhanced — Smooth Camera Fix</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { 
      height: 100%; 
      background: linear-gradient(135deg, #0a0f18 0%, #1a1f28 100%); 
      color: #fff; 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; 
      overflow: hidden;
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
    }
    
    #gameContainer { 
      position: relative; 
      width: 100vw; 
      height: 100vh; 
    }
    
    canvas { 
      display: block; 
      width: 100%; 
      height: 100%; 
      cursor: grab; 
    }
    
    canvas:active { cursor: grabbing; }

    /* Enhanced HUD with animations */
    #hud {
      position: fixed; 
      top: 0.5rem; 
      left: 0.5rem; 
      right: 0.5rem; 
      z-index: 20;
      display: flex; 
      gap: 0.5rem; 
      flex-wrap: wrap; 
      align-items: center; 
      pointer-events: none;
      animation: slideDown 0.5s ease-out;
    }
    
    @keyframes slideDown {
      from { transform: translateY(-100%); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }
    
    .panel { 
      pointer-events: auto; 
      padding: 0.4rem 0.7rem; 
      background: rgba(0,0,0,0.6); 
      border: 1px solid rgba(255,255,255,0.2); 
      border-radius: 12px; 
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      transition: all 0.3s ease;
      font-size: 0.9rem;
    }
    
    .panel:hover {
      background: rgba(0,0,0,0.8);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    
    #speedTag { 
      color: #ffb400; 
      font-weight: 700; 
      text-shadow: 0 0 10px rgba(255,180,0,0.5);
    }
    
    /* Score animation */
    @keyframes scorePopup {
      0% { transform: scale(1); }
      50% { transform: scale(1.2); }
      100% { transform: scale(1); }
    }
    
    .score-updated {
      animation: scorePopup 0.3s ease;
    }

    /* Enhanced Start overlay */
    #overlay { 
      position: fixed; 
      inset: 0; 
      display: grid; 
      place-items: center; 
      z-index: 30;
      background: rgba(0,0,0,0.85);
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
    }
    
    #overlay .box {
      width: min(720px, 92vw); 
      padding: 2rem; 
      text-align: center;
      background: linear-gradient(135deg, rgba(10,15,24,0.95) 0%, rgba(26,31,40,0.95) 100%);
      border: 1px solid rgba(255,255,255,0.2); 
      border-radius: 20px; 
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      box-shadow: 0 20px 60px rgba(0,0,0,0.5);
      animation: fadeInScale 0.5s ease-out;
    }
    
    @keyframes fadeInScale {
      from { opacity: 0; transform: scale(0.9); }
      to { opacity: 1; transform: scale(1); }
    }
    
    h1 {
      font-size: 2.5rem;
      background: linear-gradient(135deg, #ffe000 0%, #ffb400 100%);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 1rem;
      text-shadow: 0 2px 20px rgba(255,224,0,0.3);
    }
    
    .button, .menu-button {
      margin: 0.4rem 0.3rem; 
      padding: 0.8rem 1.5rem; 
      border-radius: 999px; 
      background: linear-gradient(135deg, #ffe000 0%, #ffb400 100%);
      color: #000; 
      font-weight: 800; 
      border: none; 
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 1rem;
      box-shadow: 0 4px 15px rgba(255,224,0,0.3);
    }
    
    .button:hover, .menu-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(255,224,0,0.4);
    }
    
    .speed-row { 
      margin: 1.5rem 0; 
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 0.5rem;
    }
    
    .speed-button { 
      padding: 0.6rem 1rem; 
      border-radius: 999px; 
      border: 2px solid transparent;
      background: linear-gradient(135deg, #2c7be5 0%, #1e5dff 100%);
      color: #fff; 
      font-weight: 700; 
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 0.9rem;
    }
    
    .speed-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(44,123,229,0.4);
    }
    
    .speed-button.active { 
      background: linear-gradient(135deg, #ff9800 0%, #ff6b00 100%);
      border-color: rgba(255,152,0,0.3);
      box-shadow: 0 0 20px rgba(255,152,0,0.3);
    }
    
    .speed-button.super { 
      background: linear-gradient(135deg, #e91e63 0%, #c2185b 100%);
    }

    /* Mobile controls */
    #mobileControls {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 25;
      display: none;
      gap: 10px;
      opacity: 0.8;
    }
    
    .touch-button {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background: rgba(255,255,255,0.1);
      border: 2px solid rgba(255,255,255,0.3);
      display: grid;
      place-items: center;
      touch-action: none;
      transition: all 0.1s ease;
    }
    
    .touch-button:active {
      background: rgba(255,255,255,0.3);
      transform: scale(0.95);
    }
    
    .touch-button svg {
      width: 30px;
      height: 30px;
      fill: white;
    }
    
    #dpad {
      position: relative;
      width: 150px;
      height: 150px;
    }
    
    .dpad-button {
      position: absolute;
      width: 50px;
      height: 50px;
      background: rgba(255,255,255,0.1);
      border: 2px solid rgba(255,255,255,0.3);
      border-radius: 10px;
    }
    
    .dpad-button:active {
      background: rgba(255,255,255,0.3);
    }
    
    #dpadUp { top: 0; left: 50px; }
    #dpadDown { bottom: 0; left: 50px; }
    #dpadLeft { left: 0; top: 50px; }
    #dpadRight { right: 0; top: 50px; }
    
    #jumpButton {
      position: absolute;
      right: 20px;
      bottom: 40px;
      width: 80px;
      height: 80px;
    }

    /* Pause menu enhanced */
    #pauseMenu { 
      position: fixed; 
      inset: 0; 
      display: none; 
      place-items: center; 
      z-index: 40;
      background: rgba(0,0,0,0.9);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    
    #pauseMenu .box {
      width: min(420px, 92vw); 
      padding: 2rem; 
      text-align: center;
      background: linear-gradient(135deg, rgba(10,15,24,0.98) 0%, rgba(26,31,40,0.98) 100%);
      border: 1px solid rgba(255,255,255,0.2); 
      border-radius: 20px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.5);
    }

    /* Enhanced Minimap */
    #minimap { 
      position: fixed; 
      bottom: 0.6rem; 
      left: 0.6rem; 
      z-index: 25;
      background: rgba(0,0,0,0.7); 
      border: 1px solid rgba(255,255,255,0.2); 
      border-radius: 12px; 
      padding: 0.4rem; 
      width: 200px; 
      height: 140px; 
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      transition: all 0.3s ease;
    }
    
    #minimap:hover {
      transform: scale(1.1);
      box-shadow: 0 4px 20px rgba(0,0,0,0.4);
    }
    
    #minimap canvas { 
      width: 100%; 
      height: 100%; 
      display: block; 
      border-radius: 8px;
    }

    #help { 
      position: fixed; 
      bottom: 0.6rem; 
      right: 0.6rem; 
      z-index: 25;
      background: rgba(0,0,0,0.6); 
      border: 1px solid rgba(255,255,255,0.2); 
      border-radius: 12px; 
      padding: 0.6rem 0.8rem; 
      font-size: 11px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      max-width: 300px;
      line-height: 1.4;
    }
    
    /* Settings panel */
    #settings {
      position: fixed;
      top: 0.5rem;
      right: 0.5rem;
      z-index: 25;
    }
    
    .settings-button {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: rgba(0,0,0,0.6);
      border: 1px solid rgba(255,255,255,0.2);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      cursor: pointer;
      display: grid;
      place-items: center;
      transition: all 0.3s ease;
    }
    
    .settings-button:hover {
      background: rgba(0,0,0,0.8);
      transform: rotate(90deg);
    }
    
    .settings-menu {
      position: absolute;
      top: 50px;
      right: 0;
      background: rgba(0,0,0,0.8);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 12px;
      padding: 1rem;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      display: none;
      min-width: 200px;
    }
    
    .settings-menu.open {
      display: block;
      animation: fadeInScale 0.3s ease;
    }
    
    .setting-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 0.5rem 0;
      font-size: 0.9rem;
    }
    
    .toggle {
      width: 50px;
      height: 26px;
      background: rgba(255,255,255,0.2);
      border-radius: 13px;
      position: relative;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .toggle.on {
      background: linear-gradient(135deg, #ffe000 0%, #ffb400 100%);
    }
    
    .toggle-slider {
      position: absolute;
      top: 3px;
      left: 3px;
      width: 20px;
      height: 20px;
      background: white;
      border-radius: 50%;
      transition: all 0.3s ease;
    }
    
    .toggle.on .toggle-slider {
      transform: translateX(24px);
    }
    
    /* Performance indicator */
    #fps {
      position: fixed;
      top: 0.5rem;
      right: 60px;
      z-index: 25;
      padding: 0.3rem 0.6rem;
      background: rgba(0,0,0,0.6);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 8px;
      font-size: 12px;
      font-family: monospace;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    
    /* Responsive improvements */
    @media (max-width: 768px) {
      #hud {
        font-size: 0.8rem;
      }
      
      .panel {
        padding: 0.3rem 0.5rem;
        font-size: 0.8rem;
      }
      
      h1 {
        font-size: 1.8rem;
      }
      
      #mobileControls {
        display: flex;
      }
      
      #help {
        display: none;
      }
      
      #minimap {
        width: 120px;
        height: 84px;
      }
    }
    
    @media (max-width: 480px) {
      .speed-button {
        font-size: 0.8rem;
        padding: 0.5rem 0.8rem;
      }
    }
  </style>
</head>
<body>
  <div id="gameContainer"></div>

  <div id="hud">
    <div class="panel">Score: <span id="uiScore">0</span></div>
    <div class="panel">Lives: <span id="uiLives">3</span></div>
    <div class="panel">Level: <span id="uiLevel">1</span></div>
    <div class="panel">Dots: <span id="uiDots">0</span></div>
    <div class="panel">Mode: <span id="speedTag">Beginner</span></div>
    <div class="panel" id="uiJumps" style="display:none;">Jumps: <span id="uiJumpsNum">3</span></div>
  </div>

  <div id="fps">60 FPS</div>

  <div id="settings">
    <div class="settings-button" onclick="toggleSettings()">⚙️</div>
    <div class="settings-menu" id="settingsMenu">
      <div class="setting-item">
        <span>Sound</span>
        <div class="toggle on" id="soundToggle" onclick="toggleSound()">
          <div class="toggle-slider"></div>
        </div>
      </div>
      <div class="setting-item">
        <span>Music</span>
        <div class="toggle on" id="musicToggle" onclick="toggleMusicSetting()">
          <div class="toggle-slider"></div>
        </div>
      </div>
      <div class="setting-item">
        <span>Particles</span>
        <div class="toggle on" id="particlesToggle" onclick="toggleParticles()">
          <div class="toggle-slider"></div>
        </div>
      </div>
      <div class="setting-item">
        <span>Show FPS</span>
        <div class="toggle on" id="fpsToggle" onclick="toggleFPS()">
          <div class="toggle-slider"></div>
        </div>
      </div>
    </div>
  </div>

  <div id="overlay">
    <div class="box">
      <h1>🎮 Pac‑Man 3D</h1>
      <p style="margin: 1rem 0; color: rgba(255,255,255,0.8);">
        <strong>Enhanced Edition</strong> with smooth camera and mobile support
      </p>
      <p style="margin: 1rem 0; font-size: 0.9rem; color: rgba(255,255,255,0.6);">
        🖱️ Drag to rotate • 📱 Touch controls • ⌨️ Arrow/WASD keys • Space to jump (Super mode)
      </p>
      <div class="speed-row">
        <button class="speed-button active" data-speed="beginner">🌱 Beginner</button>
        <button class="speed-button" data-speed="normal">⚡ Normal</button>
        <button class="speed-button" data-speed="expert">🔥 Expert</button>
        <button class="speed-button super" data-speed="super">💎 Super</button>
      </div>
      <button id="btnStart" class="button">Start Game</button>
    </div>
  </div>

  <div id="pauseMenu">
    <div class="box">
      <h2>⏸️ Paused</h2>
      <p style="margin: 1rem 0; color: rgba(255,255,255,0.7);">Press ESC to resume</p>
      <div style="margin-top:1rem;">
        <button id="btnResume" class="menu-button">▶️ Continue</button>
        <button id="btnRestart" class="menu-button">🔄 Restart</button>
        <button id="btnQuit" class="menu-button">🏠 Main Menu</button>
      </div>
    </div>
  </div>

  <div id="minimap"><canvas id="minimapCanvas" width="200" height="140"></canvas></div>
  <div id="help">🖱️ Drag: rotate • Wheel: zoom • ⌨️ Arrows/WASD • Space: jump • ESC: pause</div>

  <div id="mobileControls">
    <div id="dpad">
      <div class="dpad-button" id="dpadUp" data-dir="up"></div>
      <div class="dpad-button" id="dpadDown" data-dir="down"></div>
      <div class="dpad-button" id="dpadLeft" data-dir="left"></div>
      <div class="dpad-button" id="dpadRight" data-dir="right"></div>
    </div>
    <div class="touch-button" id="jumpButton">
      <svg viewBox="0 0 24 24"><path d="M7 14l5-5 5 5z"/></svg>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

    // ============= SAFE STORAGE WRAPPER =============
    const SafeStorage = {
      isAvailable: false,
      data: {},
      
      init() {
        try {
          const testKey = '__test__';
          localStorage.setItem(testKey, 'test');
          localStorage.removeItem(testKey);
          this.isAvailable = true;
        } catch (e) {
          console.log('localStorage not available, using in-memory storage');
          this.isAvailable = false;
        }
      },
      
      getItem(key) {
        if (this.isAvailable) {
          try {
            return localStorage.getItem(key);
          } catch (e) {
            return this.data[key] || null;
          }
        }
        return this.data[key] || null;
      },
      
      setItem(key, value) {
        if (this.isAvailable) {
          try {
            localStorage.setItem(key, value);
            return;
          } catch (e) {}
        }
        this.data[key] = value;
      },
      
      removeItem(key) {
        if (this.isAvailable) {
          try {
            localStorage.removeItem(key);
            return;
          } catch (e) {}
        }
        delete this.data[key];
      }
    };
    
    SafeStorage.init();

    // ============= INITIALIZATION =============
    const GameState = { Menu:"menu", Playing:"playing", Paused:"paused", GameOver:"over", LevelComplete:"clear" };
    let state = GameState.Menu;

    // Game settings
    let gameSpeed = "beginner";
    let speedMultiplier = 1.0;
    let jumpsMax = 0, jumpsRemaining = 0;
    let particlesEnabled = true;
    let musicEnabled = true;
    let soundEnabled = true;
    let showFPS = true;

    // Movement/grid
    const GRID = 1.0;
    const STEP_PER_SEC = 3.6;
    let currentMaze;
    let pacGrid = { x: 0, z: 0 };
    let pacDir = { x: 1, z: 0 };
    let pacNextDir = null;
    let moving = false, jumping = false;
    let moveFrom = null, moveTo = null;
    let moveT = 0;
    let jumpFrom = null, jumpTo = null;
    let jumpT = 0;

    // Scene objects
    let scene, camera, renderer, floorMesh, wallGroup, dotInstanced, pelletInstanced;
    let particleSystem;
    const gameEl = document.getElementById('gameContainer');

    // FIXED CAMERA SYSTEM - Complete rewrite for smooth following
    let orbit = { 
      distance: 14, 
      minDist: 6, 
      maxDist: 28, 
      tilt: 1.0, 
      minTilt: 0.2, 
      maxTilt: 1.55, 
      yaw: 0
    };
    
    // Mouse/touch interaction
    let isDragging = false, dragButton = 0, lastMouse = { x: 0, y: 0 }, shiftHold = false;
    let touchStartX = 0, touchStartY = 0, isTouchDragging = false;
    
    // FIXED: New camera smoothing system with adaptive behavior
    class SmoothCamera {
      constructor() {
        this.target = new THREE.Vector3();
        this.smoothTarget = new THREE.Vector3();
        this.velocity = new THREE.Vector3();
        this.lastTarget = new THREE.Vector3();
        
        // Adaptive smoothing parameters
        this.baseSmoothing = 0.92;  // Higher = smoother (0.9-0.99)
        this.velocityDamping = 0.85; // Velocity decay
        this.snapThreshold = 0.001;  // Distance below which we snap to target
        this.maxVelocity = 2.0;      // Maximum velocity magnitude
        
        // Mode-specific adjustments
        this.smoothingFactors = {
          beginner: { base: 0.88, damping: 0.82 },
          normal: { base: 0.88, damping: 0.82 },
          expert: { base: 0.92, damping: 0.88 },    // More smoothing for larger maze
          super: { base: 0.94, damping: 0.90 }      // Even more smoothing
        };
      }
      
      setTarget(x, y, z) {
        this.target.set(x, y, z);
      }
      
      update(deltaTime, mode = 'beginner', isDragging = false) {
        // Get mode-specific factors
        const factors = this.smoothingFactors[mode] || this.smoothingFactors.beginner;
        
        // Calculate distance to target
        const distance = this.smoothTarget.distanceTo(this.target);
        
        // If very close, snap to target to prevent micro-oscillations
        if (distance < this.snapThreshold && !isDragging) {
          this.smoothTarget.copy(this.target);
          this.velocity.set(0, 0, 0);
          return this.smoothTarget;
        }
        
        // Calculate desired velocity
        const desiredVelocity = new THREE.Vector3()
          .subVectors(this.target, this.smoothTarget)
          .multiplyScalar(1.0 - factors.base);
        
        // Apply velocity damping
        this.velocity.lerp(desiredVelocity, 1.0 - factors.damping);
        
        // Clamp velocity magnitude
        if (this.velocity.length() > this.maxVelocity) {
          this.velocity.normalize().multiplyScalar(this.maxVelocity);
        }
        
        // Update position
        this.smoothTarget.add(this.velocity);
        
        // Store last target for next frame
        this.lastTarget.copy(this.smoothTarget);
        
        return this.smoothTarget;
      }
      
      reset(position) {
        this.target.copy(position);
        this.smoothTarget.copy(position);
        this.lastTarget.copy(position);
        this.velocity.set(0, 0, 0);
      }
    }
    
    // Initialize the smooth camera system
    const smoothCamera = new SmoothCamera();

    // Actors
    let pacRoot, pacBody, pacMouth;
    let ghosts = [];

    // Game stats
    let score = 0, lives = 3, level = 1, dotCount = 0, vulnerableTimer = 0, spawnFreezeFrames = 60;
    let highScore = parseInt(SafeStorage.getItem('pacman3d_highscore') || '0');

    // UI elements
    const elScore = document.getElementById('uiScore');
    const elLives = document.getElementById('uiLives');
    const elLevel = document.getElementById('uiLevel');
    const elDots  = document.getElementById('uiDots');
    const elSpeed = document.getElementById('speedTag');
    const elJumpsWrap = document.getElementById('uiJumps');
    const elJumpsNum = document.getElementById('uiJumpsNum');
    const overlay = document.getElementById('overlay');
    const pauseMenu = document.getElementById('pauseMenu');
    const elFPS = document.getElementById('fps');

    // Minimap
    const miniCanvas = document.getElementById('minimapCanvas');
    const miniCtx = miniCanvas.getContext('2d');

    // Performance monitoring
    let frameCount = 0;
    let lastFPSUpdate = performance.now();
    let currentFPS = 60;

    // ============= AUDIO SYSTEM =============
    let audioCtx;
    let musicTimer = null;
    
    function initAudio(){ 
      if (!audioCtx) {
        try {
          audioCtx = new (window.AudioContext||window.webkitAudioContext)();
        } catch (e) {
          console.warn('Audio context creation failed:', e);
        }
      }
    }
    
    function playTone(f, dur, type='square', gain=0.08, decay=0.9){
      if (!audioCtx || !soundEnabled) return;
      try {
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = type;
        o.frequency.setValueAtTime(f, audioCtx.currentTime);
        g.gain.setValueAtTime(gain, audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + dur*decay);
        o.connect(g).connect(audioCtx.destination);
        o.start(); 
        o.stop(audioCtx.currentTime + dur);
      } catch(e) {
        console.warn('Audio playback failed:', e);
      }
    }
    
    function sfx(name){
      if (!soundEnabled) return;
      switch(name){
        case 'eat': playTone(700, 0.07, 'square', 0.09); break;
        case 'pellet': 
          playTone(260, 0.18, 'sawtooth', 0.12); 
          playTone(520, 0.18, 'triangle', 0.06); 
          break;
        case 'jump': 
          playTone(300, 0.12, 'sine', 0.12); 
          playTone(600, 0.12, 'sine', 0.08); 
          break;
        case 'teleport': 
          playTone(1100, 0.1, 'sine', 0.1); 
          playTone(300, 0.2, 'sine', 0.1); 
          break;
        case 'caught': 
          playTone(200, 0.25, 'triangle', 0.15); 
          playTone(140, 0.25, 'triangle', 0.12); 
          break;
        case 'death': 
          [800,600,400,220,110].forEach((f,i)=>setTimeout(()=>playTone(f,0.12,'sawtooth',0.12,1.0), i*80)); 
          break;
        case 'level': 
          [523,659,784,1046].forEach((f,i)=>setTimeout(()=>playTone(f,0.12,'square',0.1), i*90)); 
          break;
        case 'pause': playTone(880, 0.08, 'sine', 0.08); break;
        case 'resume': playTone(660, 0.08, 'sine', 0.08); break;
        case 'gameover': 
          [392,370,349,330,311].forEach((f,i)=>setTimeout(()=>playTone(f,0.2,'sawtooth',0.12), i*140)); 
          break;
        case 'eatGhost': 
          playTone(440, 0.15, 'sine', 0.1); 
          playTone(880, 0.15, 'sine', 0.08); 
          break;
      }
    }
    
    function startMusic(){
      if (!audioCtx || musicTimer || !soundEnabled || !musicEnabled) return;
      const tempo = 148;
      const beatMs = 60000/tempo;
      const notes = [
        659, 784, 740, 659, 523, 659, 784, 988,
        880, 784, 659, 740, 659, 523, 440, 523
      ];
      let idx = 0;
      musicTimer = setInterval(()=>{
        if (state !== GameState.Playing || !musicEnabled) return;
        const f = notes[idx % notes.length];
        playTone(f, 0.12, 'square', 0.06, 1.0);
        idx++;
      }, beatMs/2);
    }
    
    function stopMusic(){ 
      if (musicTimer){ 
        clearInterval(musicTimer); 
        musicTimer = null; 
      } 
    }

    // ============= MAZE DATA =============
    const standardMaze = [
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
      [1,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1],
      [1,3,1,1,2,1,1,1,2,1,1,1,2,1,1,1,2,1,1,3,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,2,1,1,2,1,2,1,1,1,0,1,1,1,2,1,2,1,1,2,1],
      [1,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1,2,2,2,2,1],
      [1,1,1,1,2,1,1,1,2,1,0,1,2,1,1,1,2,1,1,1,1],
      [1,2,2,2,2,2,2,2,2,1,0,1,2,2,2,2,2,2,2,2,1],
      [1,2,1,1,2,1,2,1,2,1,1,1,2,1,2,1,2,1,1,2,1],
      [1,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1,2,2,2,2,1],
      [1,2,1,1,2,1,2,1,1,1,0,1,1,1,2,1,2,1,1,2,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,3,1,1,2,1,1,1,2,1,1,1,2,1,1,1,2,1,1,3,1],
      [1,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1],
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    ];
    
    const extendedMaze = [
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,3,1,1,2,1,1,1,2,1,1,1,2,1,2,1,2,1,2,1,1,1,2,1,1,1,2,1,1,3,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,2,1,1,2,1,2,1,1,1,2,1,1,1,2,1,2,1,1,1,2,1,1,1,2,1,2,1,1,2,1],
      [1,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,1],
      [1,1,1,1,2,1,2,1,2,1,1,1,2,1,0,1,0,1,2,1,1,1,2,1,2,1,2,1,1,1,1],
      [4,2,2,2,2,2,2,1,2,2,2,2,2,1,0,1,0,1,2,2,2,2,2,1,2,2,2,2,2,2,4],
      [1,1,1,1,2,1,2,1,2,1,1,1,2,1,1,1,1,1,2,1,1,1,2,1,2,1,2,1,1,1,1],
      [1,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,1],
      [1,2,1,1,2,1,2,1,1,1,2,1,1,1,2,1,2,1,1,1,2,1,1,1,2,1,2,1,1,2,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,3,1,1,2,1,1,1,2,1,1,1,2,1,2,1,2,1,2,1,1,1,2,1,1,1,2,1,1,3,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    ];

    // ============= HELPERS =============
    const cloneMaze = (m)=> m.map(r => r.slice());
    
    const gridToWorld = (gx,gz) => {
      const cols = currentMaze[0].length, rows = currentMaze.length;
      return { x:(gx-cols/2)*GRID + GRID/2, z:(gz-rows/2)*GRID + GRID/2 };
    };
    
    const isWalkable = (gx,gz) => {
      if (gz<0||gz>=currentMaze.length||gx<0||gx>=currentMaze[0].length) return false;
      return currentMaze[gz][gx] !== 1;
    };
    
    const isInBounds = (gx,gz) => {
      return gx >= 0 && gx < currentMaze[0].length && gz >= 0 && gz < currentMaze.length;
    };

    function buildMazeData(){
      currentMaze = (gameSpeed==='beginner' || gameSpeed==='normal') ? cloneMaze(standardMaze) : cloneMaze(extendedMaze);
    }

    // ============= THREE.JS SETUP =============
    function initThree(){
      scene = new THREE.Scene();
      scene.fog = new THREE.Fog(0x00060b, 8, 80);
      
      camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.01, 500);
      
      renderer = new THREE.WebGLRenderer({ 
        antialias: true,
        powerPreference: "high-performance"
      });
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.setPixelRatio(Math.min(devicePixelRatio||1, 2));
      renderer.setSize(innerWidth, innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      gameEl.appendChild(renderer.domElement);

      // Enhanced lighting
      const hemi = new THREE.HemisphereLight(0x7aa9ff, 0x020308, 0.9);
      const dir = new THREE.DirectionalLight(0xffffff, 0.45);
      dir.position.set(16, 24, 12);
      dir.castShadow = true;
      dir.shadow.mapSize.width = 2048;
      dir.shadow.mapSize.height = 2048;
      dir.shadow.camera.near = 0.5;
      dir.shadow.camera.far = 50;
      scene.add(hemi, dir);

      // Ambient light for better visibility
      const ambient = new THREE.AmbientLight(0x303040, 0.3);
      scene.add(ambient);

      // Mouse controls
      renderer.domElement.addEventListener('mousedown', onMouseDown);
      renderer.domElement.addEventListener('mousemove', onMouseMove);
      renderer.domElement.addEventListener('mouseup', onMouseUp);
      renderer.domElement.addEventListener('mouseleave', onMouseUp);
      renderer.domElement.addEventListener('contextmenu', (e)=> e.preventDefault());
      renderer.domElement.addEventListener('wheel', onWheel, { passive: true });

      // Touch controls for mobile
      renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
      renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
      renderer.domElement.addEventListener('touchend', onTouchEnd, { passive: false });

      // Window resize
      addEventListener('resize', ()=>{
        camera.aspect = innerWidth/innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
      });
    }

    function onMouseDown(e){
      isDragging = true; 
      dragButton = e.button; 
      lastMouse.x = e.clientX; 
      lastMouse.y = e.clientY; 
      shiftHold = e.shiftKey;
    }

    function onMouseMove(e){
      if (!isDragging) return;
      const dx = e.clientX - lastMouse.x;
      const dy = e.clientY - lastMouse.y;
      lastMouse.x = e.clientX; 
      lastMouse.y = e.clientY;

      const yawSpeed = 0.005;
      const tiltSpeed = 0.003;

      if (dragButton === 0 && !shiftHold) {
        orbit.yaw -= dx * yawSpeed;
        orbit.tilt = THREE.MathUtils.clamp(orbit.tilt - dy * tiltSpeed, orbit.minTilt, orbit.maxTilt);
      }

      if (dragButton === 2 || (dragButton === 0 && shiftHold) || (dragButton === 1 && shiftHold)) {
        orbit.tilt = THREE.MathUtils.clamp(orbit.tilt - dy * tiltSpeed, orbit.minTilt, orbit.maxTilt);
      }
    }

    function onMouseUp(){
      isDragging = false;
    }

    function onWheel(e){
      const delta = Math.sign(e.deltaY);
      orbit.distance = THREE.MathUtils.clamp(orbit.distance + delta * 1.0, orbit.minDist, orbit.maxDist);
    }

    function onTouchStart(e){
      if (e.touches.length === 1) {
        isTouchDragging = true;
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
        lastMouse.x = touchStartX;
        lastMouse.y = touchStartY;
      }
      e.preventDefault();
    }

    function onTouchMove(e){
      if (!isTouchDragging || e.touches.length !== 1) return;
      
      const touch = e.touches[0];
      const dx = touch.clientX - lastMouse.x;
      const dy = touch.clientY - lastMouse.y;
      lastMouse.x = touch.clientX;
      lastMouse.y = touch.clientY;

      const yawSpeed = 0.005;
      const tiltSpeed = 0.003;

      orbit.yaw -= dx * yawSpeed;
      orbit.tilt = THREE.MathUtils.clamp(orbit.tilt - dy * tiltSpeed, orbit.minTilt, orbit.maxTilt);
      
      e.preventDefault();
    }

    function onTouchEnd(e){
      isTouchDragging = false;
      e.preventDefault();
    }

    // ============= MATERIALS =============
    function glossy(color, emissive, eInt=0.2, rough=0.35, metal=0.08){
      return new THREE.MeshStandardMaterial({ 
        color, 
        emissive, 
        emissiveIntensity: eInt, 
        roughness: rough, 
        metalness: metal 
      });
    }

    // ============= BUILD GEOMETRY =============
    function buildMazeGeometry(){
      if (wallGroup) scene.remove(wallGroup);
      if (dotInstanced?.parent) dotInstanced.parent.remove(dotInstanced);
      if (pelletInstanced?.parent) pelletInstanced.parent.remove(pelletInstanced);
      wallGroup = new THREE.Group(); 
      scene.add(wallGroup);
      dotInstanced = pelletInstanced = null; 
      dotCount = 0;

      const rows = currentMaze.length, cols = currentMaze[0].length;

      // Enhanced floor
      if (floorMesh) scene.remove(floorMesh);
      const floorGeo = new THREE.PlaneGeometry(cols*GRID+6, rows*GRID+6);
      const floorMat = new THREE.MeshStandardMaterial({ 
        color: 0x0a0f18, 
        roughness: 0.95,
        metalness: 0.05
      });
      const floor = new THREE.Mesh(floorGeo, floorMat);
      floor.rotation.x = -Math.PI/2; 
      floor.position.y = 0;
      floor.receiveShadow = true;
      scene.add(floor); 
      floorMesh = floor;

      // Enhanced walls
      const wallMat = new THREE.MeshStandardMaterial({ 
        color: 0x083070, 
        roughness: 0.45, 
        metalness: 0.1, 
        emissive: 0x081225, 
        emissiveIntensity: 0.25 
      });
      
      for (let r=0; r<rows; r++){
        let c=0;
        while(c<cols){
          if (currentMaze[r][c]===1){
            let s=c; 
            while(c<cols && currentMaze[r][c]===1) c++;
            const e=c-1, len=e-s+1;
            const geom = new THREE.BoxGeometry(GRID*len, 2.0, GRID);
            const mesh = new THREE.Mesh(geom, wallMat);
            const x = ((s+e)/2 - cols/2)*GRID + GRID/2;
            const z = (r - rows/2)*GRID + GRID/2;
            mesh.position.set(x, 1.0, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            wallGroup.add(mesh);
          } else c++;
        }
      }

      // Count dots and pellets
      let dotN=0, pelN=0;
      for (let r=0; r<rows; r++) for(let c=0; c<cols; c++){
        const v=currentMaze[r][c];
        if (v===2) dotN++; 
        else if (v===3) pelN++;
      }
      
      // Create instanced dots
      if (dotN>0){
        const dotGeo = new THREE.SphereGeometry(0.12, 16, 16);
        const dotMat = glossy(0xffffff, 0xffffff, 0.7, 0.25, 0.0);
        dotInstanced = new THREE.InstancedMesh(dotGeo, dotMat, dotN);
        dotInstanced.castShadow = true;
        wallGroup.add(dotInstanced);
      }
      
      // Create instanced pellets
      if (pelN>0){
        const pelletGeo = new THREE.SphereGeometry(0.22, 20, 20);
        const pelletMat = glossy(0xfff36b, 0xfff36b, 0.9, 0.2, 0.0);
        pelletInstanced = new THREE.InstancedMesh(pelletGeo, pelletMat, pelN);
        pelletInstanced.castShadow = true;
        wallGroup.add(pelletInstanced);
      }
      
      // Position dots and pellets
      const dummy = new THREE.Object3D(); 
      let di=0, pi=0;
      for (let r=0; r<rows; r++) for(let c=0; c<cols; c++){
        const v=currentMaze[r][c];
        const {x,z}=gridToWorld(c,r);
        if (v===2 && dotInstanced){
          dummy.position.set(x, 0.35, z); 
          dummy.updateMatrix(); 
          dotInstanced.setMatrixAt(di++, dummy.matrix); 
          dotCount++;
        } else if (v===3 && pelletInstanced){
          dummy.position.set(x, 0.35, z); 
          dummy.updateMatrix(); 
          pelletInstanced.setMatrixAt(pi++, dummy.matrix); 
          dotCount++;
        }
      }
      
      if (dotInstanced) dotInstanced.instanceMatrix.needsUpdate = true;
      if (pelletInstanced) pelletInstanced.instanceMatrix.needsUpdate = true;

      // Create Pac-Man
      createPacMan();
      
      // Initialize particle system
      if (particlesEnabled) {
        createParticleSystem();
      }

      elDots.textContent = dotCount;
    }

    function createPacMan(){
      if (pacRoot) scene.remove(pacRoot);
      pacRoot = new THREE.Group();

      // Enhanced Pac-Man body
      pacBody = new THREE.Mesh(
        new THREE.SphereGeometry(0.42, 32, 32),
        glossy(0xffe000, 0x221400, 0.25, 0.25, 0.12)
      );
      pacBody.position.y = 0.5;
      pacBody.castShadow = true;

      // Eyes
      const eyeWhiteGeo = new THREE.SphereGeometry(0.08, 16, 16);
      const eyeWhiteMat = glossy(0xffffff, 0xffffff, 0.15, 0.3, 0.0);
      const eyeBlackGeo = new THREE.SphereGeometry(0.04, 16, 16);
      const eyeBlackMat = new THREE.MeshStandardMaterial({ color:0x000000, roughness:0.8 });

      const eyeLw = new THREE.Mesh(eyeWhiteGeo, eyeWhiteMat);
      const eyeRw = new THREE.Mesh(eyeWhiteGeo, eyeWhiteMat);
      const eyeLp = new THREE.Mesh(eyeBlackGeo, eyeBlackMat);
      const eyeRp = new THREE.Mesh(eyeBlackGeo, eyeBlackMat);
      
      eyeLw.position.set(0.18, 0.62, 0.14);
      eyeRw.position.set(0.18, 0.62, -0.14);
      eyeLp.position.set(0.22, 0.62, 0.14);
      eyeRp.position.set(0.22, 0.62, -0.14);

      // Mouth
      pacMouth = new THREE.Mesh(
        new THREE.ConeGeometry(0.44, 0.62, 28, 1, true, 0, Math.PI/1.15),
        new THREE.MeshStandardMaterial({ 
          color:0x000000, 
          metalness:0.0, 
          roughness:1.0, 
          emissive:0x000000, 
          side:THREE.DoubleSide 
        })
      );
      pacMouth.position.set(0.02, 0.5, 0);
      pacMouth.rotation.z = Math.PI/2;

      pacRoot.add(pacBody, pacMouth, eyeLw, eyeRw, eyeLp, eyeRp);
      scene.add(pacRoot);
    }

    // ============= PARTICLE SYSTEM =============
    function createParticleSystem(){
      if (particleSystem) scene.remove(particleSystem);
      
      const particleCount = 100;
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);
      const colors = new Float32Array(particleCount * 3);
      
      for (let i = 0; i < particleCount; i++) {
        positions[i * 3] = (Math.random() - 0.5) * 50;
        positions[i * 3 + 1] = Math.random() * 10;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 50;
        
        colors[i * 3] = 1;
        colors[i * 3 + 1] = 1;
        colors[i * 3 + 2] = 1;
      }
      
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      
      const material = new THREE.PointsMaterial({
        size: 0.05,
        vertexColors: true,
        transparent: true,
        opacity: 0.6,
        blending: THREE.AdditiveBlending
      });
      
      particleSystem = new THREE.Points(geometry, material);
      scene.add(particleSystem);
    }

    // ============= GHOSTS =============
    function scallopedSkirt(radius=0.4, height=0.3, lobes=6){
      const group = new THREE.Group();
      const cyl = new THREE.Mesh(
        new THREE.CylinderGeometry(radius, radius, height, 24), 
        glossy(0xffffff, 0xffffff, 0.08, 0.7, 0.0)
      );
      group.add(cyl);
      
      const ballGeo = new THREE.SphereGeometry(radius*0.32, 12, 12);
      for (let i=0; i<lobes; i++){
        const a = i / lobes * Math.PI*2;
        const b = new THREE.Mesh(ballGeo, cyl.material);
        b.position.set(Math.cos(a)*radius*0.82, -height*0.5, Math.sin(a)*radius*0.82);
        group.add(b);
      }
      return group;
    }
    
    function makeGhost(color, gx, gz, personality){
      const g = new THREE.Group();
      
      const dome = new THREE.Mesh(
        new THREE.SphereGeometry(0.4, 28, 28, 0, Math.PI*2, 0, Math.PI),
        glossy(color, color, 0.12, 0.55, 0.05)
      );
      dome.castShadow = true;
      
      const skirtGroup = scallopedSkirt(0.4, 0.3, 6);
      skirtGroup.traverse(n=>{ 
        if (n.isMesh){ 
          n.material = glossy(color, color, 0.1, 0.65, 0.05);
          n.castShadow = true;
        }
      });
      skirtGroup.position.y = -0.35;

      // Ghost eyes
      const gEyeWhiteGeo = new THREE.SphereGeometry(0.1, 16, 16);
      const gEyeWhiteMat = glossy(0xffffff, 0xffffff, 0.1, 0.3, 0.0);
      const gPupilGeo = new THREE.SphereGeometry(0.05, 16, 16);
      const gPupilMat = new THREE.MeshStandardMaterial({ color:0x000000, roughness:0.8 });

      const eLw = new THREE.Mesh(gEyeWhiteGeo, gEyeWhiteMat);
      const eRw = new THREE.Mesh(gEyeWhiteGeo, gEyeWhiteMat);
      const eLp = new THREE.Mesh(gPupilGeo, gPupilMat);
      const eRp = new THREE.Mesh(gPupilGeo, gPupilMat);
      
      eLw.position.set(0.16, 0.05, 0.15);
      eRw.position.set(0.16, 0.05, -0.15);
      eLp.position.set(0.22, 0.05, 0.15);
      eRp.position.set(0.22, 0.05, -0.15);

      g.add(dome, skirtGroup, eLw, eRw, eLp, eRp);

      const w = gridToWorld(gx,gz); 
      g.position.set(w.x, 0.45, w.z);
      g.userData = { 
        grid:{x:gx,z:gz}, 
        target:{x:gx,z:gz}, 
        moving:false, 
        t:0, 
        dir:null, 
        personality, 
        freeze:spawnFreezeFrames 
      };
      
      scene.add(g);
      return g;
    }
    
    function spawnGhosts(){
      ghosts.forEach(g=>scene.remove(g)); 
      ghosts=[];
      
      const rows=currentMaze.length, cols=currentMaze[0].length;
      const corners = [
        {x:1,z:1},
        {x:cols-2,z:1},
        {x:1,z:rows-2},
        {x:cols-2,z:rows-2}
      ].map(p=> isWalkable(p.x,p.z) ? p : {x:Math.max(1,Math.min(cols-2,p.x-1)), z:Math.max(1,Math.min(rows-2,p.z-1))});
      
      const colors=[0xff3b3b,0xff7fd4,0x6fd9ff,0xffae42];
      const minds = ['aggressive','ambush','patrol','random'];
      
      for(let i=0; i<4; i++){
        const c=corners[i]; 
        ghosts.push(makeGhost(colors[i], c.x, c.z, minds[i]));
      }
    }

    // ============= GAME LOGIC =============
    function findStartPosition(){
      const rows=currentMaze.length, cols=currentMaze[0].length;
      const cx=Math.floor(cols/2), cz=Math.floor(rows/2);
      const L=Math.max(rows,cols);
      
      for(let r=0; r<L; r++){
        for(let dz=-r; dz<=r; dz++) for(let dx=-r; dx<=r; dx++){
          const x=cx+dx, z=cz+dz;
          if (z<0||z>=rows||x<0||x>=cols) continue;
          const v=currentMaze[z][x];
          if (v!==1 && v!==4) return {x,z};
        }
      }
      return {x:cx,z:cz};
    }

    function placePac(){
      const start=findStartPosition();
      pacGrid={...start};
      const wp=gridToWorld(pacGrid.x,pacGrid.z);
      pacRoot.position.set(wp.x, 0, wp.z);
      
      // Reset camera smoothing system
      smoothCamera.reset(pacRoot.position);
      
      pacDir = { x: 1, z: 0 };
      pacNextDir = null; 
      moving=false; 
      moveT=0; 
      moveFrom=moveTo=null; 
      jumping=false; 
      jumpT=0;
      setPacRotation();
    }

    function setPacRotation(){
      const ang = Math.atan2(pacDir.z, pacDir.x);
      pacRoot.rotation.y = -ang;
    }

    function tryAdoptNextDir(){
      if (!pacNextDir) return;
      if (!moving && !jumping){
        const nx = pacGrid.x + pacNextDir.x, nz = pacGrid.z + pacNextDir.z;
        if (isWalkable(nx, nz)) {
          pacDir = pacNextDir; 
          pacNextDir = null;
          setPacRotation();
          beginStep(nx, nz);
        }
      }
    }
    
    function continueForwardIfPossible(){
      if (moving || jumping) return;
      const nx = pacGrid.x + pacDir.x, nz = pacGrid.z + pacDir.z;
      if (isWalkable(nx, nz)) beginStep(nx, nz);
    }
    
    function beginStep(nx, nz){
      moving = true; 
      moveT = 0;
      const from = gridToWorld(pacGrid.x, pacGrid.z);
      const to = gridToWorld(nx, nz);
      moveFrom = new THREE.Vector3(from.x, 0, from.z);
      moveTo   = new THREE.Vector3(to.x,   0, to.z);
      pacGrid = { x:nx, z:nz };
    }

    function forceJumpNow(){
      if (jumping || jumpsRemaining <= 0 || gameSpeed !== 'super') return;

      let currentGridX = pacGrid.x;
      let currentGridZ = pacGrid.z;
      
      if (moving) {
        moving = false; 
        moveT = 0;
        const center = gridToWorld(currentGridX, currentGridZ);
        pacRoot.position.set(center.x, 0, center.z);
      }

      const midX = currentGridX + pacDir.x;
      const midZ = currentGridZ + pacDir.z;
      const landX = currentGridX + pacDir.x * 2;
      const landZ = currentGridZ + pacDir.z * 2;

      if (!isInBounds(landX, landZ)) return;
      if (!isWalkable(landX, landZ)) return;

      jumping = true; 
      jumpT = 0;
      
      const from = gridToWorld(currentGridX, currentGridZ);
      const to = gridToWorld(landX, landZ);
      jumpFrom = new THREE.Vector3(from.x, 0, from.z);
      jumpTo = new THREE.Vector3(to.x, 0, to.z);

      jumpsRemaining--;
      updateHUD();
      sfx('jump');

      pacGrid = { x: landX, z: landZ };

      if (isInBounds(midX, midZ)) {
        collectCellAt(midX, midZ);
      }
      
      collectCurrentCell();
    }

    function collectCurrentCell(){ 
      collectCellAt(pacGrid.x, pacGrid.z); 
    }
    
    function collectCellAt(gx, gz){
      if (!isInBounds(gx, gz)) return;
      const v = currentMaze[gz][gx];
      if (v===2 || v===3){
        currentMaze[gz][gx] = 0;
        dotCount = Math.max(0, dotCount-1);
        
        if (v===2){ 
          score += 10; 
          sfx('eat');
          showScorePopup(10, gx, gz);
        } else { 
          score += 50; 
          vulnerableTimer = Math.floor(5/speedMultiplier*60); 
          sfx('pellet'); 
          makeGhostsVulnerable();
          showScorePopup(50, gx, gz);
        }
        
        updateHUD(); 
        updateMinimap();
        
        if (dotCount===0){ 
          sfx('level'); 
          levelComplete(); 
        }
        
        rebuildDotsVisual();
      }
    }

    function showScorePopup(points, gx, gz){
      const scoreEl = document.getElementById('uiScore');
      scoreEl.classList.add('score-updated');
      setTimeout(() => scoreEl.classList.remove('score-updated'), 300);
    }

    function rebuildDotsVisual(){
      if (dotInstanced?.parent) dotInstanced.parent.remove(dotInstanced);
      if (pelletInstanced?.parent) pelletInstanced.parent.remove(pelletInstanced);
      dotInstanced = pelletInstanced = null;
      
      const rows=currentMaze.length, cols=currentMaze[0].length;
      let dotN=0, pelN=0;
      
      for(let r=0; r<rows; r++) for(let c=0; c<cols; c++){
        const v=currentMaze[r][c]; 
        if (v===2) dotN++; 
        else if (v===3) pelN++;
      }
      
      if (dotN>0){
        const dotGeo = new THREE.SphereGeometry(0.12, 16, 16);
        const dotMat = glossy(0xffffff, 0xffffff, 0.7, 0.25, 0.0);
        dotInstanced = new THREE.InstancedMesh(dotGeo, dotMat, dotN);
        dotInstanced.castShadow = true;
        wallGroup.add(dotInstanced);
      }
      
      if (pelN>0){
        const pelletGeo = new THREE.SphereGeometry(0.22, 20, 20);
        const pelletMat = glossy(0xfff36b, 0xfff36b, 0.9, 0.2, 0.0);
        pelletInstanced = new THREE.InstancedMesh(pelletGeo, pelletMat, pelN);
        pelletInstanced.castShadow = true;
        wallGroup.add(pelletInstanced);
      }
      
      const dummy = new THREE.Object3D(); 
      let di=0, pi=0;
      
      for(let r=0; r<rows; r++) for(let c=0; c<cols; c++){
        const v=currentMaze[r][c]; 
        const {x,z}=gridToWorld(c,r);
        if (v===2 && dotInstanced){ 
          dummy.position.set(x,0.35,z); 
          dummy.updateMatrix(); 
          dotInstanced.setMatrixAt(di++, dummy.matrix); 
        } else if (v===3 && pelletInstanced){ 
          dummy.position.set(x,0.35,z); 
          dummy.updateMatrix(); 
          pelletInstanced.setMatrixAt(pi++, dummy.matrix); 
        }
      }
      
      if (dotInstanced) dotInstanced.instanceMatrix.needsUpdate = true;
      if (pelletInstanced) pelletInstanced.instanceMatrix.needsUpdate = true;
    }

    function makeGhostsVulnerable(){
      ghosts.forEach(g=>g.traverse(ch=>{
        if (ch.material?.emissive){
          ch.material.color.setHex(0x1e5dff);
          ch.material.emissive.setHex(0x1e5dff);
          ch.material.emissiveIntensity=0.35;
        }
      }));
    }
    
    function restoreGhosts(){
      const colors=[0xff3b3b,0xff7fd4,0x6fd9ff,0xffae42];
      ghosts.forEach((g,i)=>g.traverse(ch=>{
        if (ch.material?.emissive){
          const col=colors[i%colors.length];
          ch.material.color.setHex(col);
          ch.material.emissive.setHex(col);
          ch.material.emissiveIntensity=0.12;
        }
      }));
    }

    // ============= AI & MOVEMENT =============
    function updateGhostAI(g){
      if (g.userData.freeze>0){ 
        g.userData.freeze--; 
        return; 
      }
      if (g.userData.moving) return;
      
      const dirs=[{x:1,z:0},{x:-1,z:0},{x:0,z:1},{x:0,z:-1}];
      const gg=g.userData.grid;
      const manh=(x1,z1,x2,z2)=>Math.abs(x1-x2)+Math.abs(z1-z2);
      let best=null;
      
      if (vulnerableTimer>0){
        let maxD=-1;
        for(const d of dirs){
          const nx=gg.x+d.x, nz=gg.z+d.z;
          if (isWalkable(nx,nz)){
            const dist=manh(nx,nz,pacGrid.x,pacGrid.z);
            if (dist>maxD){
              maxD=dist; 
              best=d;
            }
          }
        }
      } else {
        // Enhanced AI based on personality
        switch(g.userData.personality) {
          case 'aggressive':
            let minD=Infinity;
            for(const d of dirs){
              const nx=gg.x+d.x, nz=gg.z+d.z;
              if (isWalkable(nx,nz)){
                const dist=manh(nx,nz,pacGrid.x,pacGrid.z);
                if (dist<minD){
                  minD=dist; 
                  best=d;
                }
              }
            }
            break;
            
          case 'ambush':
            const futureX = pacGrid.x + pacDir.x * 4;
            const futureZ = pacGrid.z + pacDir.z * 4;
            let minAmbush=Infinity;
            for(const d of dirs){
              const nx=gg.x+d.x, nz=gg.z+d.z;
              if (isWalkable(nx,nz)){
                const dist=manh(nx,nz,futureX,futureZ);
                if (dist<minAmbush){
                  minAmbush=dist; 
                  best=d;
                }
              }
            }
            break;
            
          case 'patrol':
            const patrolCenterX = Math.floor(currentMaze[0].length / 2);
            const patrolCenterZ = Math.floor(currentMaze.length / 2);
            let minPatrol=Infinity;
            for(const d of dirs){
              const nx=gg.x+d.x, nz=gg.z+d.z;
              if (isWalkable(nx,nz)){
                const distToCenter=manh(nx,nz,patrolCenterX,patrolCenterZ);
                const distToPac=manh(nx,nz,pacGrid.x,pacGrid.z);
                const score = distToCenter * 0.3 + distToPac * 0.7;
                if (score<minPatrol){
                  minPatrol=score; 
                  best=d;
                }
              }
            }
            break;
            
          case 'random':
          default:
            const validDirs = dirs.filter(d => {
              const nx=gg.x+d.x, nz=gg.z+d.z;
              return isWalkable(nx,nz);
            });
            if (validDirs.length > 0) {
              best = validDirs[Math.floor(Math.random() * validDirs.length)];
            }
            break;
        }
      }
      
      if (best){
        g.userData.dir=best; 
        g.userData.target={x:gg.x+best.x, z:gg.z+best.z};
        g.userData.moving=true; 
        g.userData.t=0;
      }
    }

    function updateGhosts(dt){
      ghosts.forEach((g,i)=>{
        updateGhostAI(g);
        
        if (g.userData.moving){
          g.userData.t += STEP_PER_SEC*0.8*dt*speedMultiplier / 1.0;
          const t=Math.min(1,g.userData.t);
          const from=gridToWorld(g.userData.grid.x,g.userData.grid.z);
          const to=gridToWorld(g.userData.target.x,g.userData.target.z);
          g.position.set(from.x+(to.x-from.x)*t, 0.45, from.z+(to.z-from.z)*t);
          
          if (t>=1){
            g.userData.grid={...g.userData.target};
            g.userData.moving=false; 
            g.userData.t=0;
          }
        }
        
        // Collision detection
        const sameTile = (g.userData.grid.x===pacGrid.x && g.userData.grid.z===pacGrid.z);
        if (sameTile && !jumping){
          if (vulnerableTimer>0){
            score+=200; 
            updateHUD(); 
            sfx('eatGhost');
            showScorePopup(200, pacGrid.x, pacGrid.z);
            
            const rows=currentMaze.length, cols=currentMaze[0].length;
            const corners=[{x:1,z:1},{x:cols-2,z:1},{x:1,z:rows-2},{x:cols-2,z:rows-2}];
            const pos=corners[i%4];
            g.userData.grid={...pos}; 
            g.userData.target={...pos}; 
            g.userData.moving=false; 
            g.userData.t=0; 
            g.userData.freeze=spawnFreezeFrames;
            const w=gridToWorld(pos.x,pos.z); 
            g.position.set(w.x,0.45,w.z);
          } else if (state===GameState.Playing){
            sfx('caught');
            lives--; 
            updateHUD(); 
            sfx('death');
            if (lives<=0) gameOver(); 
            else resetRound();
          }
        }
      });

      // Vulnerable timer and flashing
      if (vulnerableTimer>0){
        vulnerableTimer--;
        if (vulnerableTimer<60 && (vulnerableTimer%10)<5){
          ghosts.forEach(g=>g.traverse(ch=>{ 
            if (ch.material?.emissive) ch.material.emissive.setHex(0xffffff); 
          }));
        } else {
          ghosts.forEach(g=>g.traverse(ch=>{ 
            if (ch.material?.emissive) ch.material.emissive.setHex(0x1e5dff); 
          }));
        }
        if (vulnerableTimer<=0) restoreGhosts();
      }
    }

    // ============= FIXED CAMERA UPDATE =============
    function updateCamera(dt){
      // Update smooth camera target
      smoothCamera.setTarget(pacRoot.position.x, 0, pacRoot.position.z);
      const smoothTarget = smoothCamera.update(dt, gameSpeed, isDragging || isTouchDragging);
      
      // Calculate camera position using orbit parameters
      const up = new THREE.Vector3(0, 1, 0);
      const forward = new THREE.Vector3(Math.cos(orbit.yaw), 0, Math.sin(orbit.yaw));
      const offset = new THREE.Vector3();
      const h = Math.cos(orbit.tilt) * orbit.distance;
      const y = Math.sin(orbit.tilt) * orbit.distance;
      offset.copy(forward).multiplyScalar(-h).addScaledVector(up, y);
      
      // Set camera position relative to smoothed target
      const cameraPos = smoothTarget.clone().add(offset);
      camera.position.copy(cameraPos);
      
      // Look at smoothed target with slight offset upward
      camera.lookAt(smoothTarget.x, 0.2, smoothTarget.z);
    }

    // ============= MINIMAP =============
    function updateMinimap(){
      const W=miniCanvas.width,H=miniCanvas.height;
      miniCtx.clearRect(0,0,W,H);
      
      // Draw gradient background
      const gradient = miniCtx.createLinearGradient(0, 0, W, H);
      gradient.addColorStop(0, 'rgba(10,15,24,0.9)');
      gradient.addColorStop(1, 'rgba(26,31,40,0.9)');
      miniCtx.fillStyle = gradient;
      miniCtx.fillRect(0, 0, W, H);
      
      const rows=currentMaze.length, cols=currentMaze[0].length;
      const sx=W/cols, sy=H/rows;
      
      // Draw walls
      miniCtx.fillStyle="#0b2a66";
      for(let r=0; r<rows; r++) for(let c=0; c<cols; c++) {
        if (currentMaze[r][c]===1) {
          miniCtx.fillRect(c*sx,r*sy,sx,sy);
        }
      }
      
      // Draw dots and pellets
      miniCtx.fillStyle="#fff";
      for(let r=0; r<rows; r++) for(let c=0; c<cols; c++){
        const v=currentMaze[r][c]; 
        if (v===2||v===3){
          const cx=c*sx+sx/2, cy=r*sy+sy/2;
          miniCtx.beginPath(); 
          miniCtx.arc(cx,cy, v===3?2.3:1.3, 0,Math.PI*2); 
          miniCtx.fill();
        }
      }
      
      // Draw Pac-Man with glow effect
      miniCtx.shadowColor = "#ffe000";
      miniCtx.shadowBlur = 10;
      miniCtx.fillStyle="#ffe000";
      miniCtx.beginPath(); 
      miniCtx.arc(pacGrid.x*sx+sx/2, pacGrid.z*sy+sy/2, 3, 0, Math.PI*2); 
      miniCtx.fill();
      miniCtx.shadowBlur = 0;
      
      // Draw ghosts
      const colsG=["#ff4d4d","#ff8ae2","#4da6ff","#ffb14d"];
      ghosts.forEach((g,i)=>{
        miniCtx.fillStyle=vulnerableTimer>0 ? "#1e5dff" : colsG[i%colsG.length];
        miniCtx.beginPath(); 
        miniCtx.arc(g.userData.grid.x*sx+sx/2, g.userData.grid.z*sy+sy/2, 2.5, 0,Math.PI*2); 
        miniCtx.fill();
      });
    }

    // ============= GAME FLOW =============
    function setMode(speed){
      gameSpeed = speed;
      document.querySelectorAll('.speed-button').forEach(b=>b.classList.toggle('active', b.dataset.speed===speed));
      
      if (speed==='beginner'){ 
        speedMultiplier=0.9; 
        jumpsMax=0; 
      } else if (speed==='normal'){ 
        speedMultiplier=1.0; 
        jumpsMax=0; 
      } else if (speed==='expert'){ 
        speedMultiplier=1.25; 
        jumpsMax=0; 
      } else { 
        speedMultiplier=1.5; 
        jumpsMax=3; 
      }
      
      elSpeed.textContent = speed[0].toUpperCase()+speed.slice(1);
      elJumpsWrap.style.display = (speed==='super') ? '' : 'none';
      elJumpsNum.textContent = String(jumpsMax);
    }
    
    function updateHUD(){ 
      elScore.textContent=score; 
      elLives.textContent=lives; 
      elLevel.textContent=level; 
      elDots.textContent=dotCount; 
      if (gameSpeed==='super') elJumpsNum.textContent=String(jumpsRemaining);
      
      // Update high score safely
      if (score > highScore) {
        highScore = score;
        SafeStorage.setItem('pacman3d_highscore', String(highScore));
      }
    }

    function startGame(){
      overlay.style.display='none'; 
      pauseMenu.style.display='none';
      if (!audioCtx) initAudio();
      
      score=0; 
      lives=3; 
      level=1; 
      updateHUD();

      buildMazeData();
      buildMazeGeometry();
      placePac();
      spawnGhosts();
      jumpsRemaining = jumpsMax;
      updateHUD();
      updateMinimap();

      orbit.distance = (gameSpeed==='beginner' || gameSpeed==='normal') ? 12 : 16;
      orbit.tilt = 1.0; 
      orbit.yaw = 0;

      state=GameState.Playing;
      startMusic();
    }

    function resetRound(){
      placePac();
      if (gameSpeed==='super') jumpsRemaining=jumpsMax;
      spawnGhosts();
      updateHUD(); 
      updateMinimap();
    }

    function pauseGame(){ 
      if (state===GameState.Playing){ 
        state=GameState.Paused; 
        pauseMenu.style.display='grid'; 
        stopMusic(); 
        sfx('pause'); 
      } 
    }
    
    function resumeGame(){ 
      if (state===GameState.Paused){ 
        state=GameState.Playing; 
        pauseMenu.style.display='none'; 
        startMusic(); 
        sfx('resume'); 
      } 
    }

    function gameOver(){
      state=GameState.GameOver;
      stopMusic();
      sfx('gameover');
      overlay.style.display='grid';
      overlay.querySelector('.box').innerHTML = `
        <h1>💀 Game Over</h1>
        <p style="margin: 1rem 0; font-size: 1.2rem;">Final Score: <strong style="color: #ffe000;">${score}</strong></p>
        <p style="margin: 0.5rem 0; color: rgba(255,255,255,0.7);">High Score: ${highScore}</p>
        <div class="speed-row">
          <button class="speed-button ${gameSpeed==='beginner'?'active':''}" data-speed="beginner">🌱 Beginner</button>
          <button class="speed-button ${gameSpeed==='normal'?'active':''}" data-speed="normal">⚡ Normal</button>
          <button class="speed-button ${gameSpeed==='expert'?'active':''}" data-speed="expert">🔥 Expert</button>
          <button class="speed-button super ${gameSpeed==='super'?'active':''}" data-speed="super">💎 Super</button>
        </div>
        <button id="btnStart" class="button">Play Again</button>
      `;
      overlay.querySelectorAll('.speed-button').forEach(b=>b.addEventListener('click',()=>setMode(b.dataset.speed)));
      overlay.querySelector('#btnStart').addEventListener('click', startGame);
    }

    function levelComplete(){
      state = GameState.LevelComplete;
      stopMusic();
      overlay.style.display='grid';
      overlay.querySelector('.box').innerHTML = `
        <h1>🎉 Level ${level} Complete!</h1>
        <p style="margin: 1rem 0; font-size: 1.1rem;">Score: <strong style="color: #ffe000;">${score}</strong></p>
        <button id="btnNext" class="button">Next Level →</button>
      `;
      overlay.querySelector('#btnNext').addEventListener('click', nextLevel);
    }
    
    function nextLevel(){
      overlay.style.display='none';
      level++; 
      updateHUD();
      buildMazeData();
      buildMazeGeometry();
      resetRound();
      state=GameState.Playing;
      startMusic();
    }

    // ============= INPUT HANDLING =============
    const keys = {};
    
    function bindInput(){
      // Keyboard input
      document.addEventListener('keydown', (e)=>{
        keys[e.key.toLowerCase()] = true;
        const k = e.key.toLowerCase();
        
        if (["arrowup","arrowdown","arrowleft","arrowright","w","a","s","d"," "].includes(k)) {
          e.preventDefault();
        }

        if (e.key==="Escape"){
          if (state===GameState.Playing) pauseGame();
          else if (state===GameState.Paused) resumeGame();
          return;
        }

        if (state!==GameState.Playing) return;

        if (k===" " && gameSpeed==='super') { 
          forceJumpNow(); 
          return; 
        }

        if (k==="arrowup"||k==="w") pacNextDir = { x: 0, z: -1 };
        else if (k==="arrowdown"||k==="s") pacNextDir = { x: 0, z: 1 };
        else if (k==="arrowleft"||k==="a") pacNextDir = { x: -1, z: 0 };
        else if (k==="arrowright"||k==="d") pacNextDir = { x: 1, z: 0 };

        tryAdoptNextDir();
        continueForwardIfPossible();
      });
      
      document.addEventListener('keyup', (e)=>{ 
        keys[e.key.toLowerCase()] = false; 
      });

      // Mobile D-pad controls
      const dpadButtons = document.querySelectorAll('.dpad-button');
      dpadButtons.forEach(btn => {
        btn.addEventListener('touchstart', (e) => {
          e.preventDefault();
          const dir = btn.dataset.dir;
          if (state !== GameState.Playing) return;
          
          if (dir === 'up') pacNextDir = { x: 0, z: -1 };
          else if (dir === 'down') pacNextDir = { x: 0, z: 1 };
          else if (dir === 'left') pacNextDir = { x: -1, z: 0 };
          else if (dir === 'right') pacNextDir = { x: 1, z: 0 };
          
          tryAdoptNextDir();
          continueForwardIfPossible();
        });
      });

      // Jump button for mobile
      const jumpBtn = document.getElementById('jumpButton');
      if (jumpBtn) {
        jumpBtn.addEventListener('touchstart', (e) => {
          e.preventDefault();
          if (state === GameState.Playing && gameSpeed === 'super') {
            forceJumpNow();
          }
        });
      }

      // Pause menu buttons
      document.getElementById('btnResume').addEventListener('click', resumeGame);
      document.getElementById('btnRestart').addEventListener('click', ()=>{ 
        buildMazeData(); 
        buildMazeGeometry(); 
        resetRound(); 
        state=GameState.Playing; 
        pauseMenu.style.display='none'; 
        startMusic(); 
      });
      document.getElementById('btnQuit').addEventListener('click', ()=>{
        state=GameState.Menu;
        pauseMenu.style.display='none';
        stopMusic();
        location.reload();
      });
    }

    // ============= SETTINGS =============
    window.toggleSettings = function() {
      const menu = document.getElementById('settingsMenu');
      menu.classList.toggle('open');
    };

    window.toggleSound = function() {
      soundEnabled = !soundEnabled;
      const toggle = document.getElementById('soundToggle');
      toggle.classList.toggle('on');
      if (!soundEnabled) stopMusic();
      else if (state === GameState.Playing) startMusic();
    };

    window.toggleMusicSetting = function() {
      musicEnabled = !musicEnabled;
      const toggle = document.getElementById('musicToggle');
      toggle.classList.toggle('on');
      if (!musicEnabled) stopMusic();
      else if (state === GameState.Playing && soundEnabled) startMusic();
    };

    window.toggleParticles = function() {
      particlesEnabled = !particlesEnabled;
      const toggle = document.getElementById('particlesToggle');
      toggle.classList.toggle('on');
      if (particlesEnabled && !particleSystem) {
        createParticleSystem();
      } else if (!particlesEnabled && particleSystem) {
        scene.remove(particleSystem);
        particleSystem = null;
      }
    };

    window.toggleFPS = function() {
      showFPS = !showFPS;
      const toggle = document.getElementById('fpsToggle');
      toggle.classList.toggle('on');
      elFPS.style.display = showFPS ? 'block' : 'none';
    };

    // ============= ANIMATION LOOP =============
    let last = performance.now();
    let chewPhase = 0;
    
    function animate(){
      requestAnimationFrame(animate);
      
      const now = performance.now();
      const dt = Math.min(0.05, (now - last) / 1000); 
      last = now;
      
      // Update FPS counter
      frameCount++;
      if (now - lastFPSUpdate >= 1000) {
        currentFPS = Math.round(frameCount * 1000 / (now - lastFPSUpdate));
        if (showFPS) {
          elFPS.textContent = `${currentFPS} FPS`;
        }
        frameCount = 0;
        lastFPSUpdate = now;
      }
      
      if (state === GameState.Playing){
        // Pac-Man movement
        if (moving){
          moveT += STEP_PER_SEC * dt * speedMultiplier / 1.0;
          const t = Math.min(1, moveT);
          const x = moveFrom.x + (moveTo.x - moveFrom.x) * t;
          const z = moveFrom.z + (moveTo.z - moveFrom.z) * t;
          pacRoot.position.set(x, 0, z);
          
          if (t >= 1){
            moving = false; 
            moveT = 0;
            collectCurrentCell();
            
            // Handle tunnels
            if ((gameSpeed === 'expert' || gameSpeed === 'super') && currentMaze[pacGrid.z][pacGrid.x] === 4){
              const cols = currentMaze[0].length;
              if (pacGrid.x === 0) pacGrid.x = cols - 1;
              else if (pacGrid.x === cols - 1) pacGrid.x = 0;
              const wp = gridToWorld(pacGrid.x, pacGrid.z);
              pacRoot.position.set(wp.x, 0, wp.z);
              sfx('teleport');
            }
            
            tryAdoptNextDir();
            continueForwardIfPossible();
          }
        }

        // Jump animation
        if (jumping){
          const jumpSpeed = 3.0;
          jumpT += jumpSpeed * dt * speedMultiplier / 1.0;
          const t = Math.min(1, jumpT);
          const x = THREE.MathUtils.lerp(jumpFrom.x, jumpTo.x, t);
          const z = THREE.MathUtils.lerp(jumpFrom.z, jumpTo.z, t);
          const y = Math.sin(t * Math.PI) * 1.6;
          pacRoot.position.set(x, y, z);
          
          if (t >= 1){
            jumping = false; 
            jumpT = 0;
            pacRoot.position.set(jumpTo.x, 0, jumpTo.z);
            tryAdoptNextDir();
            continueForwardIfPossible();
          }
        }

        // Pac-Man mouth animation
        chewPhase += dt * 10;
        const open = 0.35 + Math.max(0, Math.sin(chewPhase)) * 0.4 * ((moving || jumping) ? 1 : 0.3);
        pacMouth.rotation.y = open;
        pacMouth.visible = true;

        // Update ghosts
        updateGhosts(dt);
        
        // Update minimap
        updateMinimap();
        
        // Update camera with deltaTime for smooth following
        updateCamera(dt);
        
        // Update particles
        if (particleSystem) {
          particleSystem.rotation.y += dt * 0.1;
          const positions = particleSystem.geometry.attributes.position.array;
          for (let i = 0; i < positions.length; i += 3) {
            positions[i + 1] -= dt * 0.5;
            if (positions[i + 1] < 0) {
              positions[i + 1] = 10;
            }
          }
          particleSystem.geometry.attributes.position.needsUpdate = true;
        }
      }
      
      renderer.render(scene, camera);
    }

    // ============= UI BINDINGS =============
    function bindUI(){
      document.querySelectorAll('.speed-button').forEach(b => {
        b.addEventListener('click', () => setMode(b.dataset.speed));
      });
      document.getElementById('btnStart').addEventListener('click', startGame);
    }

    // ============= INITIALIZATION =============
    initThree();
    bindUI();
    bindInput();
    setMode('beginner');
    updateHUD();
    animate();
    overlay.style.display = 'grid';
    pauseMenu.style.display = 'none';
    
    // Check for mobile
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    if (isMobile) {
      document.getElementById('mobileControls').style.display = 'flex';
    }
  </script>
</body>
</html>